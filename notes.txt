
Visual Studio Code / Web Storm / Atom
Node.js (LTS 12.X)
Chrome

Application for the Browser
    Presentation
    State
    Behavior


Server driven web applications

JavaScript

Data Types
    Number, String, Boolean, Object, Undefined, Function

Programming Constructs
    var, if then else, switch case, for, while, throw, try catch finally, function

APIs
    Array, Math, Date, RegEx, Timer (setTimeout, clearTimeout, setInterval, clearInterval), Error

Unique Aspects

    Object
        Disctionary / Map
        Key Value pair collection
        Key can be string / number
        Attributes can be accessed using the dot (.) notation / square brackets ([]) notation
        Are dynamic
        A method is nothing but an attribute with a function as the value

    Function
        is also an object
            functions can have attributes
            functions can have methods
            functions can be assigned to variables
            functions can be passed as arguments to other functions
            functions can be returned as return value from another function

        variadic functions are supported

        arguments & this
            are the two implicit values passed to the function

            arguments
                array like object containing all the values passed to the function
                indexer, .length attribute supported

            this
                invocation context
                based on 'how' the function is invoked
                    - As a method of an object, 
                        this -> object
                
                    - As a function
                        this -> global scope (window)

                    - using the 'call' method of the function

                    - using the 'apply' method of the function

function add(){
    function parseArg(n){
        if (typeof n === 'function') return parseArg(n());
        if (Array.isArray(n)) return add.apply(undefined, n);
        return (isNaN(n)) ?  0 : parseInt(n);
    }
    return arguments.length <= 1 ? parseArg(arguments[0]) : parseArg(arguments[0]) + add([].slice.call(arguments,1));
}

add(10,20)
add(10, "20")
add(10, "abc")
add([10,20], [30,40])
add([10,20], [30,"40"])
add([10,20], [30,"abc"])
add([10,20], [30,[40, "50"]])
add(function(){ return [10,20]; }, function(){ return [30,[40, "50"]]; })
add([function(){ return [10,20]; }, function(){ return [30,[40, "50"]]; }])
add(10)
add()
add(10,20,30,40,50)

Constructor Functions
    functions that behave like classes
    NO syntax differences
    Invoked with the 'new' keyword
        this -> a new object
        this -> is returned by default
    Naming conventions - proper case

    example:
        function Employee(id, name, salary){
            //this -> new object
            if (this.constructor !== Employee)
                return new Employee(id, name, salary);

            this.id = id;
            this.name = name;
            this.salary = salary;

            this.display = function(){
                console.log(this.id, this.name, this.salary);
            }
            //this -> object is returned by default
        }

Closures
    
Prototypal Inheritance
    One object acts a base object (prototype) for a family of objects
    CF.prototype => base object

    var x = new CF();
    x.__proto__ === CF.prototype

    function Employee(id, name, salary){
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    typeof Employee.prototype
    
    Employee.prototype['city'] = 'Bangalore'
    
    Employee.prototype.display = function(){
        console.log(this.id, this.name, this.salary, this.city);
    }
    
    var emp = new Employee(100, 'Magesh', 10000)

ES6 (ESNext, ECMAScript6)
1. let
2. const
3. Array destructuring 
4. Rest operator (Array)
5. Spread operator (Array)
6. Object destructuring 
7. Rest operator (Object)
8. Spread operator (Object)
9. default arguments
10. arrow functions
11. template strings
12. class

https://es6-features.org


var products = [
    { id : 4, name : 'Pen', cost : 60, units : 20, category : 'Stationary'},
    { id : 7, name : 'Ten', cost : 20, units : 60, category : 'Utencil'},
    { id : 2, name : 'Len', cost : 40, units : 40, category : 'Stationary'},
    { id : 8, name : 'Ken', cost : 30, units : 50, category : 'Utencil'},
    { id : 6, name : 'Den', cost : 50, units : 70, category : 'Stationary'},
]

1. Find all the stationary products
2. Find out the highest cost among the products
3. Create a new list with objects containing all the attributes of the product + a new attribute called 'value' (value = cost * units)
4. From the newly created list (problem 3), print the name and value of all the products

Solve the above problems WITHOUG using any looping constructs (NO for/while/do loops)
Hint : use the 'filter, map, reduce and forEach' methods of array


Day-02
jQuery
    DOM manipulation library

    jQuery (function)

    $txtBox
        .hide()
        .val('asfadsfa')
        .fadeIn()

Node.js
    JavaScript Runtime
        Single Threaded Event Loop

    REPL
        
    COMMON JS Module system

    accumulator.js
        add(x)
        subtract(x)
        multiply(x)
        divide(x)
        getResult()

    accumulator-client.js
        acc.add(100)
        acc.subtract(50)
        acc.multiply(10)
        acc.divide(2)
        console.log(acc.getResult()) => 250

npm (node package manager)
OR yarn

manifest file (metadata information)
package.json
    name
    version
    author
    repository
    description
    keywords
    private
    license
    scripts
    dependencies

npm init - to create a package.json file

to install an open source module
    npm install <module name>


Express
    MVC frameworks

express-generator
   to generate a new application 
    npx express-generator my-api-app --no-view
    cd my-api-app
    npm install
    npm start


Middlewares
    function(req, res, next){
        
    }


React
    JavaScript library for creating complex UI applications for the browser

    Component
        = Data (Model) + Presentation (View) + UI Behavior
        = Model View synchronization
        = Rendering Performance


Babel
    Transpiler

JSX
    Every open tag MUST have the corresponding closing tag
    Use 'htmlFor' instead of 'for' attribute
    use 'className' instead of 'class' attribute

Component Lifecycle Events
    mounting
        - componentWillMount
        - componentDidMount

    updating
        - componentShouldUpdate
        - componentWillUpdate
        - render

    unmounting
        - componentWillUnmount